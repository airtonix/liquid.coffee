// Generated by CoffeeScript 1.6.3
(function() {
  module.exports = function(Liquid) {
    var Context;
    return Context = (function() {
      function Context(assigns, registers, rethrowErrors) {
        this.scopes = [(assigns ? assigns : {})];
        this.registers = (registers ? registers : {});
        this.errors = [];
        this.rethrowErrors = rethrowErrors;
        this.strainer = Liquid.Strainer.create(this);
      }

      Context.prototype.get = function(varname) {
        return this.resolve(varname);
      };

      Context.prototype.set = function(varname, value) {
        return this.scopes[0][varname] = value;
      };

      Context.prototype.hasKey = function(key) {
        if (this.resolve(key)) {
          return true;
        } else {
          return false;
        }
      };

      Context.prototype.push = function() {
        var scpObj;
        scpObj = {};
        this.scopes.unshift(scpObj);
        return scpObj;
      };

      Context.prototype.merge = function(newScope) {
        var key, val, _results;
        _results = [];
        for (key in newScope) {
          val = newScope[key];
          _results.push(this.scopes[0][key] = val);
        }
        return _results;
      };

      Context.prototype.pop = function() {
        if (this.scopes.length === 1) {
          throw "Context stack error";
        }
        return this.scopes.shift();
      };

      Context.prototype.stack = function(lambda, bind) {
        var result;
        result = null;
        this.push();
        try {
          result = lambda.apply((bind ? bind : this.strainer));
        } finally {
          this.pop();
        }
        return result;
      };

      Context.prototype.invoke = function(method, args) {
        var result;
        if (this.strainer.respondTo(method)) {
          result = this.strainer[method].apply(this.strainer, args);
          return result;
        } else {
          if (args.length === 0) {
            return null;
          } else {
            return args[0];
          }
        }
      };

      Context.prototype.resolve = function(key) {
        var arr, i, left, limit, range, result, right;
        switch (key) {
          case null:
          case "nil":
          case "null":
          case "":
            return null;
          case "true":
            return true;
          case "false":
            return false;
          case "blank":
          case "empty":
            return "";
          default:
            if (/^'(.*)'$/.test(key)) {
              return key.replace(/^'(.*)'$/, "$1");
            } else if (/^"(.*)"$/.test(key)) {
              return key.replace(/^"(.*)"$/, "$1");
            } else if (/^(\d+)$/.test(key)) {
              return parseInt(key.replace(/^(\d+)$/, "$1"));
            } else if (/^(\d[\d\.]+)$/.test(key)) {
              return parseFloat(key.replace(/^(\d[\d\.]+)$/, "$1"));
            } else if (/^\((\S+)\.\.(\S+)\)$/.test(key)) {
              range = key.match(/^\((\S+)\.\.(\S+)\)$/);
              left = parseInt(range[1]);
              right = parseInt(range[2]);
              arr = [];
              if (isNaN(left) || isNaN(right)) {
                left = range[1].charCodeAt(0);
                right = range[2].charCodeAt(0);
                limit = right - left + 1;
                i = 0;
                while (i < limit) {
                  arr.push(String.fromCharCode(i + left));
                  i++;
                }
              } else {
                limit = right - left + 1;
                i = 0;
                while (i < limit) {
                  arr.push(i + left);
                  i++;
                }
              }
              return arr;
            } else {
              result = this.variable(key);
              return result;
            }
        }
      };

      Context.prototype.findVariable = function(key) {
        var i, scope, variable;
        i = 0;
        while (i < this.scopes.length) {
          scope = this.scopes[i];
          if (scope && typeof scope[key] !== "undefined") {
            variable = scope[key];
            if (typeof variable === "function") {
              variable = variable.apply(this);
              scope[key] = variable;
            }
            if (variable && typeof variable === "object" && ("toLiquid" in variable)) {
              variable = variable.toLiquid();
            }
            if (variable && typeof variable === "object" && ("setContext" in variable)) {
              variable.setContext(self);
            }
            return variable;
          }
          i++;
        }
        return null;
      };

      Context.prototype.variable = function(markup) {
        var firstPart, object, parts, self, squareMatch;
        if (typeof markup !== "string") {
          return null;
        }
        parts = markup.match(/\[[^\]]+\]|(?:[\w\-]\??)+/g);
        firstPart = parts.shift();
        squareMatch = firstPart.match(/^\[(.*)\]$/);
        if (squareMatch) {
          firstPart = this.resolve(squareMatch[1]);
        }
        object = this.findVariable(firstPart);
        self = this;
        if (object) {
          parts.forEach(function(part) {
            var pos, res;
            squareMatch = part.match(/^\[(.*)\]$/);
            if (squareMatch) {
              part = self.resolve(squareMatch[1]);
              if (typeof object[part] === "function") {
                object[part] = object[part].apply(this);
              }
              object = object[part];
              if (typeof object === "object" && ("toLiquid" in object)) {
                return object = object.toLiquid();
              }
            } else {
              if ((typeof object === "object" || typeof object === "hash") && (part in object)) {
                res = object[part];
                if (typeof res === "function") {
                  res = object[part] = res.apply(self);
                }
                if (typeof res === "object" && ("toLiquid" in res)) {
                  object = res.toLiquid();
                } else {
                  object = res;
                }
              } else if (/^\d+$/.test(part)) {
                pos = parseInt(part);
                if (typeof object[pos] === "function") {
                  object[pos] = object[pos].apply(self);
                }
                if (typeof object[pos] === "object" && typeof object[pos] === "object" && ("toLiquid" in object[pos])) {
                  object = object[pos].toLiquid();
                } else {
                  object = object[pos];
                }
              } else if (object && typeof object[part] === "function" && (part === "length" || part === "size" || part === "first" || part === "last")) {
                object = object[part].apply(part);
                if ("toLiquid" in object) {
                  object = object.toLiquid();
                }
              } else {
                return object = null;
              }
              if (typeof object === "object" && ("setContext" in object)) {
                return object.setContext(self);
              }
            }
          });
        }
        return object;
      };

      Context.prototype.addFilters = function(filters) {
        filters = Liquid.Utils.flatten(filters);
        return filters.forEach(function(f) {
          if (typeof f !== "object") {
            throw "Expected object but got: " + typeof f;
          }
          return this.strainer.addMethods(f);
        });
      };

      Context.prototype.handleError = function(err) {
        this.errors.push(err);
        if (this.rethrowErrors) {
          throw err;
        }
        return "Liquid error: " + (err.message ? err.message : (err.description ? err.description : err));
      };

      return Context;

    })();
  };

}).call(this);
