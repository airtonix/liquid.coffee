// Generated by CoffeeScript 1.6.3
(function() {
  var Liquid,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Liquid = require('../../liquid');

  Liquid.Tags.Extends = (function(_super) {
    var Syntax;

    __extends(Extends, _super);

    Syntax = RegExp("(" + Liquid.StrictQuotedFragment.source + ")");

    function Extends(tagName, markup, tokens) {
      var $,
        _this = this;
      if ($ = markup.match(Syntax)) {
        this.name = $[1];
      } else {
        throw new Liquid.SyntaxError("Syntax Error in 'block' - Valid syntax: extends [template]");
      }
      if (tokens != null) {
        Extends.__super__.constructor.call(this, tagName, markup, tokens);
      }
      this.blocks = this.nodelist.inject({}, function(m, node) {
        if (node instanceof Liquid.Tags.Block) {
          m[node.name] = node;
          return m;
        }
      });
    }

    Extends.prototype.parse = function(tokens) {
      return this.parseAll(tokens);
    };

    Extends.prototype.render = function(context) {
      var block, name, parentBlocks, pb, template, _ref;
      template = this.loadTemplate(context);
      parentBlocks = this.findBlocks(template.root);
      _ref = this.blocks;
      for (name in _ref) {
        block = _ref[name];
        if ((pb = parentBlocks[name]) != null) {
          pb.parent = block.parent;
          pb.addParent(pb.nodelist);
          pb.nodelist = block.nodelist;
        } else {
          if (this.isExtending(template)) {
            template.root.nodelist.push(block);
          }
        }
      }
      return template.render(context);
    };

    Extends.prototype.parseAll = function(tokens) {
      var $, tag, token, _results;
      this.nodelist || (this.nodelist = []);
      this.nodelist.length = 0;
      _results = [];
      while ((token = tokens.shift()) != null) {
        if (RegExp("^" + Liquid.TagStart.source).test(token)) {
          if ($ = token.match(RegExp("^" + Liquid.TagStart.source + "\\s*(\\w+)\\s*(.*)?" + Liquid.TagEnd.source + "$"))) {
            if ((tag = Liquid.Template.tags[$[1]]) != null) {
              _results.push(this.nodelist.push(new tag($[1], $[2], tokens)));
            } else {
              _results.push(this.unknownTag($[1], $[2], tokens));
            }
          } else {
            throw new Liquid.SyntaxError("Tag '" + token + "' was not properly terminated with regexp: " + Liquid.TagEnd.source + " ");
          }
        } else if (($ = token.match(RegExp("^" + Liquid.VariableStart.source))) != null) {
          _results.push(this.nodelist.push(this.createVariable(token)));
        } else if (token === '') {

        } else {
          _results.push(this.nodelist.push(token));
        }
      }
      return _results;
    };

    Extends.prototype.loadTemplate = function(context) {
      var source;
      source = Liquid.Tags.Include.readTemplateFromFileSystem(context.get(this.template_name));
      return Liquid.Template.parse(source);
    };

    Extends.prototype.findBlocks = function(node, blocks) {
      var _this = this;
      if (blocks == null) {
        blocks = {};
      }
      if (node.respondTo(this.nodelist)) {
        node.nodelist.inject(blocks)(function(b, node) {
          if (node instanceof Liquid.Tags.Block) {
            b[node.name] = node;
          } else {
            _this.findBlocks(node, b);
          }
          return b;
        });
      }
      return blocks;
    };

    Extends.prototype.isExtending = function(template) {
      return template.root.nodelist.any(function(node) {
        return node instanceof Extends;
      });
    };

    return Extends;

  })(Liquid.Tag);

  Liquid.Template.registerTag("extends", Liquid.Tags.Extends);

}).call(this);
