// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  module.exports = function(Liquid) {
    var For;
    For = (function(_super) {
      __extends(For, _super);

      For.prototype.tagSyntax = /(\w+)\s+in\s+((?:\(?[\w\-\.\[\]]\)?)+)/;

      function For(tag, markup, tokens) {
        var attMatchs, attrmarkup, matches;
        matches = markup.match(this.tagSyntax);
        if (matches) {
          this.variableName = matches[1];
          this.collectionName = matches[2];
          this.name = this.variableName + "-" + this.collectionName;
          this.attributes = {};
          attrmarkup = markup.replace(this.tagSyntax, "");
          attMatchs = markup.match(/(\w*?)\s*\:\s*("[^"]+"|'[^']+'|[^\s,|]+)/g);
          if (attMatchs) {
            attMatchs.forEach((function(pair) {
              pair = pair.split(":");
              return this.attributes[pair[0].trim()] = pair[1].trim();
            }), this);
          }
        } else {
          throw "Syntax error in 'for loop' - Valid syntax: for [item] in [collection]";
        }
        For.__super__.constructor.call(this, tag, markup, tokens);
      }

      For.prototype.render = function(context) {
        var collection, limit, offset, output, range, rangeEnd, segment,
          _this = this;
        output = [];
        collection = context.get(this.collectionName) || [];
        range = [0, collection.length];
        if (!context.registers["for"]) {
          context.registers["for"] = {};
        }
        if (this.attributes["limit"] || this.attributes["offset"]) {
          offset = 0;
          limit = 0;
          rangeEnd = 0;
          segment = null;
          if (this.attributes["offset"] === "continue") {
            offset = context.registers["for"][this.name];
          } else {
            offset = context.get(this.attributes["offset"]) || 0;
          }
          limit = context.get(this.attributes["limit"]);
          rangeEnd = (limit ? offset + limit + 1 : collection.length);
          range = [offset, rangeEnd - 1];
          context.registers["for"][this.name] = rangeEnd;
        }
        segment = collection.slice(range[0], range[1]);
        if (!segment || segment.length === 0) {
          return "";
        }
        context.stack(function() {
          var length;
          length = segment.length;
          return segment.forEach(function(item, index) {
            context.set(_this.variableName, item);
            context.set("forloop", {
              name: _this.name,
              length: length,
              index: index + 1,
              index0: index,
              rindex: length - index,
              rindex0: length - index - 1,
              first: index === 0,
              last: index === (length - 1)
            });
            return output.push((_this.renderAll(_this.nodelist, context) || []).join(""));
          });
        });
        return Liquid.Utils.flatten([output]).join("");
      };

      return For;

    })(Liquid.Block);
    return Liquid.Template.registerTag("for", For);
  };

}).call(this);
