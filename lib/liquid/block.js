// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  module.exports = function(Liquid) {
    var Block;
    return Block = (function(_super) {
      var ContentOfVariable, FullToken, IsTag, IsVariable;

      __extends(Block, _super);

      IsTag = /^\{\%/;

      IsVariable = /^\{\{/;

      FullToken = /^\{\%\s*(\w+)\s*(.*)?\%\}$/;

      ContentOfVariable = /^\{\{(.*)\}\}$/;

      function Block(tagName, markup, tokens) {
        this.blockName = tagName;
        this.blockDelimiter = "end" + this.blockName;
        Block.__super__.constructor.call(this, tagName, markup, tokens);
      }

      Block.prototype.parse = function(tokens) {
        var tagParts, token;
        this.nodelist || (this.nodelist = []);
        this.nodelist.length = 0;
        token = tokens.shift();
        tokens.push("");
        while (tokens.length) {
          if (IsTag.test(token)) {
            if ((tagParts = token.match(FullToken)) != null) {
              if (this.blockDelimiter === tagParts[1]) {
                this.endTag();
                return;
              }
              if (tagParts[1] in Liquid.Template.tags) {
                this.nodelist.push(new Liquid.Template.tags[tagParts[1]](tagParts[1], tagParts[2], tokens));
              } else {
                this.unknownTag(tagParts[1], tagParts[2], tokens);
              }
            } else {
              throw "Tag '" + token + "' was not properly terminated with: %}";
            }
          } else if (IsVariable.test(token)) {
            this.nodelist.push(this.createVariable(token));
          } else {
            this.nodelist.push(token);
          }
          token = tokens.shift();
        }
        return this.assertMissingDelimitation();
      };

      Block.prototype.endTag = function() {};

      Block.prototype.unknownTag = function(tag, params, tokens) {
        switch (tag) {
          case "else":
            throw this.blockName + " tag does not expect else tag";
            break;
          case "end":
            throw "'end' is not a valid delimiter for " + this.blockName + " tags. use " + this.blockDelimiter;
            break;
          default:
            throw "Unknown tag: " + tag;
        }
      };

      Block.prototype.createVariable = function(token) {
        var match;
        if ((match = token.match(ContentOfVariable)) != null) {
          return new Liquid.Variable(match[1]);
        } else {
          throw "Variable '" + token + "' was not properly terminated with: }}";
        }
      };

      Block.prototype.render = function(context) {
        return this.renderAll(this.nodelist, context);
      };

      Block.prototype.renderAll = function(list, context) {
        return (list || []).map(function(token, i) {
          var e, output;
          output = "";
          try {
            output = (token["render"] ? token.render(context) : token);
          } catch (_error) {
            e = _error;
            output = context.handleError(e);
          }
          return output;
        });
      };

      Block.prototype.assertMissingDelimitation = function() {
        throw this.blockName + " tag was never closed";
      };

      return Block;

    })(Liquid.Tag);
  };

}).call(this);
